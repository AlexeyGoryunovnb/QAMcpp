# QAM.cpp
в данной программе есть три важных класса QAMModulator, Channel и QAMDemodulator.


1) QAMModulator
В этом класе происходит посторение сигнала и по сигналу построение сигнального созвездия.

QAMModulator modulator(p, T, N, I)
при инициализации элемента этого класса мы задаём:
p - определяет вид модуляции (0 - QPSK, 1 - QAM16, 2 - QAM64, 3-QAM256).
T - длительность сигнала во времени.
N - частота дискретизации.
I - число полупериодов сигнала (QAM работает коректно только если сигнал состоит из целого числа полупериодов либо если число полупериодов очень большое. В данной реализации мы считаем что сигнал может иметь только целое число полупериодов.).

void modulate(symbol, signal, time)
эта функция создаёт сигнал s_i(t). Сигналы кодируются с помощью кода Грея для уменьшения вероятности ошибки бита.
symbol - номер сигнала i который отправляется источнику на вход модулятора.
signal - после работы этой функции в этой переменной будет хранится сигнал s_i(t).
time - после работы этой функции в этой переменной будет хранится время t для последующего постоения созвездия.

void calculate_constellation(signal, time, x, y)
эта функция вычисляет координаты сигнального созвездия по средством скалярного произвидения с базисными функциями.
signal - сигнал s_i(t).
time - время t.
x и y - координаты сигнальной точки


2) Channel
В этом класе происходит моделирование канала по средством добавления шума.

void add_noise(x, y, gamma)
добавляет шум при коэфициэнте сигнал-шум = gamma
x и y - координаты сигнальной точки
gamma - коэфициэнт сигнал-шум. gamma = Е/N_0. Где Е - энергия сигнала для КАМ модуляции E = 1, N_0 - энергия шума. Дисперсия D = N_0/2, gamma = 1/(2*D)


4) QAMDemodulator
В этом класе происходит вычисление номера сигнала.

QAMDemodulator demodulator(p)
при инициализации элемента этого класса мы задаём:
p - определяет вид модуляции (0 - QPSK, 1 - QAM16, 2 - QAM64, 3-QAM256).

int demodulate(x, y)
на основе полученных координат вычисляет номер сигнала.
x и y - координаты сигнальной точки.


Програма проходит по указанным значениям дисперссии и проводит указанное число тестов.
В каждом тесте происходит модуляция, вычисление созвездия, передача по каналу и демодуляция.
Затем считается сколько бит были искажены. 
После прохождения всех тестов число искажённых битов делится на число битов на символ и на число тестов.
Все эти значения записываются в файл qam_result.dat.
Pатем создаётся gnuplot скрипт plot_script.
Если запустить этот скрипт то появится png файл DispPError в котором будет находится график зависимости вероятности ошибки бита от от дисперсии шума.

пример работы после запуска gnuplot скрипта
p = 0
![DispPError4](https://github.com/user-attachments/assets/2de69528-2c6d-4855-8410-0c317ebe0359)
p = 1
![DispPError16](https://github.com/user-attachments/assets/42201586-1f27-4b49-8ef0-ca3c6dbd9312)
p = 2
![DispPError64](https://github.com/user-attachments/assets/3b2ed13c-08cc-4cce-818a-6b91ef8da15e)
p = 3
![DispPError256](https://github.com/user-attachments/assets/7ddcace4-0832-46cf-9c65-8664235190cc)


# QAM_simple.cpp
Эта программа является вариацией первой программы, единственное отличие заключается в классе QAMModulator_simple. А так же простроены теоретические графики.

1) QAMModulator_simple
В этом класе происходит построение сигнального созвездия, без посторения самого сигнала.

QAMModulator modulator(p)
при инициализации элемента этого класса мы задаём:
p - определяет вид модуляции (0 - QPSK, 1 - QAM16, 2 - QAM64, 3-QAM256).

void modulate(symbol, x, y)
эта функция вычисляет координаты сигнального созвездия по номеру сигнала. Сигналы кодируются с помощью кода Грея для уменьшения вероятности ошибки бита.
symbol - номер сигнала i который отправляется источнику на вход модулятора.
x и y - координаты сигнальной точки.

классы Channel и QAMDemodulator идентичны тем что были ранее.

Програма так же проходит по указанным значениям дисперссии и проводит указанное число тестов.
В каждом тесте происходит вычисление созвездия, передача по каналу и демодуляция.
Затем считается сколько бит были искажены. 
После прохождения всех тестов число искажённых битов делится на число битов на символ и на число тестов.
Все эти значения записываются в файл qam_result.dat.
Pатем создаётся gnuplot скрипт plot_script, в gnuplot скрипте также мы строим график теоретической ошибки бита для QAM16, QAM64 и QAM256 мы считаем верхнюю и нижнюю
границы. Обе границы считаются на основе вероятности ошибки символа. При вычислении верхняей границы мы считаем что при ошибки символа, произходит ошибка в половине
битов. При вычислении нижней границы мы считаем что при ошибки символа, произходит ошибка в одном бите. Для QPSK, так как используется всего два бита, ошибка в
половине битов и ошибка в одном бите совподают.
Если запустить скрипт plot_script то появится png файл DispPError в котором будет находится эксперементальный график зависимости вероятности ошибки бита от дисперсии
шума. И теоретические графики.

пример работы после запуска gnuplot скрипта
p = 0
![DispPError(QPSK)](https://github.com/user-attachments/assets/2b3003b7-a429-4a6b-b25c-0bf772f73b5e)
p = 1
![DispPError(QAM16)](https://github.com/user-attachments/assets/9657ceb5-8c9c-4c37-802a-9a28584e1674)
p = 2
![DispPError(QAM64)](https://github.com/user-attachments/assets/c7fd20b9-1c49-4122-90ce-9279d1cbf1cf)
p = 3
![DispPError(QAM256)](https://github.com/user-attachments/assets/55e9b14c-5b3c-4a39-a86c-e0e6d23ad09a)
